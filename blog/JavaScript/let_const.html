<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ES6 let 与 const | Styx</title>
    <meta name="description" content="Just playing around">
    
    
    <link rel="preload" href="/assets/css/0.styles.6ba01dbc.css" as="style"><link rel="preload" href="/assets/js/app.71258bcc.js" as="script"><link rel="preload" href="/assets/js/9.0cbabbe4.js" as="script"><link rel="prefetch" href="/assets/js/10.791bcf6a.js"><link rel="prefetch" href="/assets/js/11.270d30d2.js"><link rel="prefetch" href="/assets/js/12.4f916f05.js"><link rel="prefetch" href="/assets/js/13.8e34ea2e.js"><link rel="prefetch" href="/assets/js/14.6682d968.js"><link rel="prefetch" href="/assets/js/15.349eb120.js"><link rel="prefetch" href="/assets/js/2.d56d8352.js"><link rel="prefetch" href="/assets/js/3.eee9c534.js"><link rel="prefetch" href="/assets/js/4.20264e48.js"><link rel="prefetch" href="/assets/js/5.16cece3d.js"><link rel="prefetch" href="/assets/js/6.ec7fbee3.js"><link rel="prefetch" href="/assets/js/7.f03e0f5c.js"><link rel="prefetch" href="/assets/js/8.17711977.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6ba01dbc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Styx</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Blog</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/JavaScript/" class="nav-link router-link-active">JavaScipt</a></li><li class="dropdown-item"><!----> <a href="/blog/Node/" class="nav-link">Node</a></li></ul></div></div><div class="nav-item"><a href="/blog/Projects/" class="nav-link">Projects</a></div><div class="nav-item"><a href="https://github.com/Styx11" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Blog</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/JavaScript/" class="nav-link router-link-active">JavaScipt</a></li><li class="dropdown-item"><!----> <a href="/blog/Node/" class="nav-link">Node</a></li></ul></div></div><div class="nav-item"><a href="/blog/Projects/" class="nav-link">Projects</a></div><div class="nav-item"><a href="https://github.com/Styx11" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/JavaScript/" class="sidebar-link">Fisher-Yates洗牌算法</a></li><li><a href="/blog/JavaScript/let_const.html" class="active sidebar-link">ES6 let 与 const</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/JavaScript/let_const.html#let与const的相同点" class="sidebar-link">let与const的相同点</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript/let_const.html#let与const的不同点" class="sidebar-link">let与const的不同点</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript/let_const.html#不存在变量提升" class="sidebar-link">不存在变量提升</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript/let_const.html#暂时性死区" class="sidebar-link">暂时性死区</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript/let_const.html#不允许重复声明" class="sidebar-link">不允许重复声明</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript/let_const.html#块级作用域" class="sidebar-link">块级作用域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/JavaScript/let_const.html#为什么会需要块级作用域？" class="sidebar-link">为什么会需要块级作用域？</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript/let_const.html#es6的块级作用域" class="sidebar-link">ES6的块级作用域</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/JavaScript/let_const.html#const" class="sidebar-link">const</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/JavaScript/let_const.html#变量声明必须初始化" class="sidebar-link">变量声明必须初始化</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript/let_const.html#关于变量值不可变" class="sidebar-link">关于变量值不可变</a></li></ul></li></ul></li><li><a href="/blog/JavaScript/destructing.html" class="sidebar-link">ES6 变量的解构赋值</a></li><li><a href="/blog/JavaScript/es6_string.html" class="sidebar-link">ES6 字符串的扩展</a></li><li><a href="/blog/JavaScript/array_expand.html" class="sidebar-link">ES6 数组的扩展</a></li><li><a href="/blog/JavaScript/func_expand.html" class="sidebar-link">ES6 函数的扩展</a></li><li><a href="/blog/JavaScript/obj_expand.html" class="sidebar-link">ES6 对象的扩展</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="es6-let-与-const"><a href="#es6-let-与-const" aria-hidden="true" class="header-anchor">#</a> ES6 let 与 const</h1> <p>在ES6中<code>let</code>与<code>const</code>都是用于声明变量的关键字，大致用法类似与<code>var</code>。</p> <h2 id="let与const的相同点"><a href="#let与const的相同点" aria-hidden="true" class="header-anchor">#</a> let与const的相同点</h2> <div class="tip custom-block"><p class="custom-block-title">let&amp;const</p> <ol><li>不存在变量提升</li> <li>暂时性死区</li> <li>相同作用域内变量不允许被重复声明</li> <li>块级作用域</li></ol></div> <h2 id="let与const的不同点"><a href="#let与const的不同点" aria-hidden="true" class="header-anchor">#</a> let与const的不同点</h2> <p>基本上<code>let</code>具有的特性<code>const</code>都有，所以它们的不同点主要在于<code>const</code>额外的特性：</p> <div class="tip custom-block"><p class="custom-block-title">const</p> <ol><li>const声明的变量不可变</li> <li>由于变量不可变，所以const声明的变量必须进行初始化赋值</li></ol></div> <h2 id="不存在变量提升"><a href="#不存在变量提升" aria-hidden="true" class="header-anchor">#</a> 不存在变量提升</h2> <p>在ES5中如果我们运行一下代码并不会报错：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted"> </div><br></div><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">123</span>

<span class="token comment">// 我们会得到undefined</span>
</code></pre></div><p>之所以出现这种情况，是因为<code>var</code>声明的变量可以被提前使用，就像用<code>function</code>声明的函数被提升至最顶部一样。根据编程规范我们应该先声明再使用变量。</p> <p>ES6中的<code>let</code>和<code>const</code>不允许出现这种情况：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span>
<span class="token comment">// const bar = 321;</span>

<span class="token comment">// 报错ReferenceError</span>
</code></pre></div><h2 id="暂时性死区"><a href="#暂时性死区" aria-hidden="true" class="header-anchor">#</a> 暂时性死区</h2> <p>只要块级作用域内存在<code>let</code>或<code>const</code>命令，它们所声明的变量就会绑定到该作用域，不受外部的影响</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  tmp <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
  <span class="token keyword">let</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上代码之所以会报错，就是因为在块级作用域内存在<code>let</code>或<code>const</code>命令，所以它所声明的变量就进入 <strong>死区</strong>，在声明前无法被使用。语法上称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p> <p>以下是几个暂时性死区的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> x<span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
<span class="token keyword">let</span> x<span class="token punctuation">;</span>
</code></pre></div><p>( typeof操作变得不再安全 )</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span>x <span class="token operator">=</span> y<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre></div><p>( 报错是因为 x=y 中的 y 还未被声明 )</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 不报错</span>
<span class="token keyword">var</span> x <span class="token operator">=</span> x<span class="token punctuation">;</span>

<span class="token comment">// 报错</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token comment">// ReferenceError: x is not defined</span>
</code></pre></div><p>ES6 规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p> <h2 id="不允许重复声明"><a href="#不允许重复声明" aria-hidden="true" class="header-anchor">#</a> 不允许重复声明</h2> <p>使用<code>var</code>多次声明同一变量时，实际上我们只会得到一个变量：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x<span class="token punctuation">;</span>
    <span class="token keyword">var</span> x<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面的例子里，所有x的声明实际上都引用一个相同的x，并且这是完全有效的代码。 这经常会成为bug的来源。<code>let</code>和<code>const</code>声明就不会这么宽松了。</p> <p><code>let</code>和<code>const</code>不允许在相同作用域内重复声明同一变量。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 报错</span>
<span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 报错</span>
<span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因此不允许在函数的第一层作用域内声明和参数同名的变量</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> arg<span class="token punctuation">;</span> <span class="token comment">// 报错</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">let</span> arg<span class="token punctuation">;</span> <span class="token comment">// 不报错</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="块级作用域"><a href="#块级作用域" aria-hidden="true" class="header-anchor">#</a> 块级作用域</h2> <h3 id="为什么会需要块级作用域？"><a href="#为什么会需要块级作用域？" aria-hidden="true" class="header-anchor">#</a> 为什么会需要块级作用域？</h3> <p>在ES5中我们只有全局作用域和函数作用域，这就会导致一些常见的问题：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 10</span>
</code></pre></div><p>由于不存在块级作用域，for循环中的i实际上一直是同一个变量，所以数组a内每个函数所输出的i都是指向同一个变量。</p> <p>要解决这个问题，我们通常使用立即执行函数（IIFE）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5</span>
</code></pre></div><p>为什么这样可行？因为函数是按值传递的，并且<code>function</code>内部会开辟新的变量环境，所以对IIFE传入参数i后，内部就保存了唯一的数据，这样每个函数就输出唯一的值。</p> <h3 id="es6的块级作用域"><a href="#es6的块级作用域" aria-hidden="true" class="header-anchor">#</a> ES6的块级作用域</h3> <p>ES6中的块级作用域就解决了这样的问题：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 5</span>
</code></pre></div><p>变量由let声明，于是启用了块级作用域，每次循环的i在各自的变量环境内都是独一无二的，即函数内部保存了唯一的值，而i值的计算就交给了浏览器。</p> <p><code>let</code>、<code>const</code>实际上为 JavaScript 新增了块级作用域。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由于块级作用域的存在，外部无法访问内部变量，并且变量的声明也不会冲突，即在内作用域声明的变量会<em>屏蔽</em>外层作用域内相同的变量。</p> <h2 id="const"><a href="#const" aria-hidden="true" class="header-anchor">#</a> const</h2> <p>前面介绍的特性都是<code>lei</code>和<code>const</code>共有的，所以大多数情况下可以用const代替let。</p> <h3 id="变量声明必须初始化"><a href="#变量声明必须初始化" aria-hidden="true" class="header-anchor">#</a> 变量声明必须初始化</h3> <p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p> <p>这其实就意味着声明的变量必须给定一个初始值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> foo<span class="token punctuation">;</span>
<span class="token comment">// SyntaxError: Missing initializer in const declaration</span>
</code></pre></div><p>（你必须初始化变量）</p> <h3 id="关于变量值不可变"><a href="#关于变量值不可变" aria-hidden="true" class="header-anchor">#</a> 关于变量值不可变</h3> <p>实际上<code>const</code>所保证的，是简单类型的变量不可变：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token constant">PI</span> <span class="token operator">=</span> <span class="token number">3.1415</span><span class="token punctuation">;</span>
<span class="token constant">PI</span> <span class="token comment">// 3.1415</span>

<span class="token constant">PI</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token comment">// TypeError: Assignment to constant variable.</span>
</code></pre></div><p>（你无法改变常量的值！）
但对于引用类型的值（Object、Array、Function），const只能保证引用它们的指针值不可变，也就是说你可以通过指针修改它们内部实际的值，但你不能直接改变它的指针引用另一个变量值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 为 foo 添加一个属性，可以成功</span>
foo<span class="token punctuation">.</span>prop <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span>prop <span class="token comment">// 123</span>

<span class="token comment">// 将 foo 指向另一个对象，就会报错</span>
foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: &quot;foo&quot; is read-only</span>
</code></pre></div><p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p> <p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 常规模式时，下面一行不起作用；</span>
<span class="token comment">// 严格模式时，该行会报错</span>
foo<span class="token punctuation">.</span>prop <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
</code></pre></div><p>（你无法添加新的属性）</p> <p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">constantize</span> <span class="token operator">=</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">constantize</span><span class="token punctuation">(</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/JavaScript/" class="prev router-link-active">
          Fisher-Yates洗牌算法
        </a></span> <span class="next"><a href="/blog/JavaScript/destructing.html">
          ES6 变量的解构赋值
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.71258bcc.js" defer></script><script src="/assets/js/9.0cbabbe4.js" defer></script>
  </body>
</html>
